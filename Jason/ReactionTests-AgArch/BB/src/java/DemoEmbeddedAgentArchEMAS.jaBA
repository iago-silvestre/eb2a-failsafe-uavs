package embedded.mas.bridges.jacamo;

import embedded.mas.bridges.jacamo.DefaultEmbeddedAgArch;
import embedded.mas.bridges.jacamo.IDevice;
import embedded.mas.exception.PerceivingException;

import java.util.*;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import jason.asSyntax.*;
import jason.asSyntax.Trigger;
import jason.asSyntax.LiteralImpl;
import jason.asSyntax.Trigger.TEOperator;
import jason.asSyntax.Trigger.TEType;
import jason.asSemantics.Circumstance;
import jason.asSemantics.TransitionSystem;
import jason.asSyntax.ASSyntax;
import jason.bb.BeliefBase;

public class DemoEmbeddedAgentArch extends DefaultEmbeddedAgArch {

    /** Severity band definition */
    private static class Band {
        final double min, max;
        final String label;
        Band(double min, double max, String label) {
            this.min = min; this.max = max; this.label = label;
        }
        boolean matches(double v) { return v > min && v <= max; }
    }

    /** Mapping of cpX â†’ functor name (e.g., cp0 = "temp") */
    private final Map<Integer, String> cpBindings = new HashMap<>();

    /** Severity tables per cp index */
    private final Map<Integer, List<Band>> severityTables = new HashMap<>();

    /** Last seen severity label for each cp */
    private final Map<Integer, String> lastSeverities = new HashMap<>();

    public DemoEmbeddedAgentArch() {
        super();

        // Default: cp0 is temperature with its severity bands
        cpBindings.put(0, "temp");
        severityTables.put(0, Arrays.asList(
            new Band(Double.NEGATIVE_INFINITY, 40, "None"),
            new Band(40, 50, "Marginal"),
            new Band(50, 70, "Severe"),
            new Band(70, Double.POSITIVE_INFINITY, "Critical")
        ));
        lastSeverities.put(0, "None"); // initial state
    }

    @Override
    public Boolean[] perceiveCP() {
        Boolean[] percepts = new Boolean[32]; // One for each cp0 to cp31
        Arrays.fill(percepts, Boolean.FALSE);

        Circumstance C = getTS().getC();
        C.CPM.clear();

        // For each configured CP with severity table
        for (Map.Entry<Integer, String> binding : cpBindings.entrySet()) {
            int cpIndex = binding.getKey();
            String boundFunctor = binding.getValue();

            Double val = null;

            // ðŸ”¹ Instead of BeliefBase â†’ look into devicesâ€™ percepts
            for (IDevice s : this.devices) {
                try {
                    Collection<Literal> devicePercepts = s.getPercepts();
                    if (devicePercepts == null) continue;

                    for (Literal l : devicePercepts) {
                        if (boundFunctor.equals(l.getFunctor()) &&
                            l.getArity() == 1 &&
                            l.getTerm(0).isNumeric()) {
                            try {
                                val = ((NumberTerm) l.getTerm(0)).solve();
                            } catch (Exception ignore) {}
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            if (val == null) continue;

            // Classify severity
            String newSev = classifySeverity(cpIndex, val);

            // If severity changed, trigger cbX
            String oldSev = lastSeverities.getOrDefault(cpIndex, "__none__");
            if (!newSev.equals(oldSev)) {
                lastSeverities.put(cpIndex, newSev);

                // Update BB to reflect new severity (optional if you donâ€™t want beliefs)
                String oldBeliefStr = "cp" + cpIndex + "(\"" + oldSev + "\")[source(self)]";
                getTS().getAg().getBB().remove(Literal.parseLiteral(oldBeliefStr));

                String newBeliefStr = "cp" + cpIndex + "(\"" + newSev + "\")[source(self)]";
                getTS().getAg().getBB().add(Literal.parseLiteral(newBeliefStr));

                // Add cbX percept
                Literal percept = new LiteralImpl("cb" + cpIndex);
                Trigger te = new Trigger(TEOperator.add, TEType.belief, percept);
                C.CPM.put(te.getPredicateIndicator(), true);

                percepts[cpIndex] = Boolean.TRUE;
                //System.out.println("Percepts: " + Arrays.toString(percepts));
            }
        }

        return percepts;
    }

    /** Extracts numeric value from belief base for given functor */
    private Double extractNumericValue(BeliefBase bb, String functor) {
        for (Literal l : bb) {
            if (functor.equals(l.getFunctor()) &&
                l.getArity() == 1 &&
                l.getTerm(0).isNumeric()) {
                try {
                    return ((NumberTerm) l.getTerm(0)).solve();
                } catch (Exception ignore) {}
            }
        }
        return null;
    }

    /** Classify value into severity band for given cp index */
    private String classifySeverity(int cpIndex, double val) {
        List<Band> bands = severityTables.get(cpIndex);
        if (bands == null) return "Unknown";
        for (Band b : bands) {
            if (b.matches(val)) return b.label;
        }
        return "Unknown";
    }

}
